
# A form builder that uses css to produce tableless, lined-up forms.
#
class CssFormBuilder < ActionView::Helpers::FormBuilder
  
   (field_helpers - %w(hidden_field)).each do |selector|
    src = <<-END_SRC
      def #{selector}(field, options = {})
        process(field,options,super(field,options.purge_custom_tags))
      end
    END_SRC
    class_eval src, __FILE__, __LINE__
  end
  
  def select(field,choises,options={},html_options={})
    process(field,html_options,super(field,choises,options,html_options.purge_custom_tags))
  end
  
  def date_select(field,options={})
    process(field,options,super(field,options.purge_custom_tags))
  end
  
  def radio_button(field,tag_value,options={})
    process(field,options,super(field,tag_value,options.purge_custom_tags))
  end

  # Like _select_, but accepts a _select_choices_ parameter that is a string of option tags, that can be generated by
  # _options_for_select_, _option_groups_from_collection_for_select_, ..
  def select_with_choises(field, select_choices, options = {}, html_options = {})
    process(field,html_options,super(field,select_choices,options,html_options.purge_custom_tags))
  end
  
  # Returns a date field and calendar that pops up when the calendar image is clicked.
  #--
  # derived from Calendar Helper, by Michael Schuerig, michael@schuerig.de, 2005
  def date_field(field, html_options = {}, date_options={})
    button_image = html_options[:button_image] || 'calendar.gif'
    date_value = @object.send(field)
    unless date_value.nil?
      format_string=date_options[:ifFormat] || '%m/%d/%y'
      date_value=date_value.strftime(format_string) 
    end
    input_field_name = "#{@object_name}[#{field}]"
    input_field_id = "#{@object_name}_#{field}" 
    calendar_id = "#{@object_name}_#{field}_calendar" 
    calendar_setup = date_options.merge({:inputField => input_field_id,:button=>calendar_id})
    calendar = @template.image_tag(button_image,:id => calendar_id)
    s=<<-END
    #{calendar}
    <script type="text/javascript">
      Calendar.setup({ #{calendar_setup.collect { |key,value| key.to_s + ':' + value.inspect }.join(',')} })
    </script>
    END
    html_options.merge!({:extra=>s,:value=>date_value,:size=>html_options[:size] || 10})
    text_field(field,html_options)
  end
  
  def  fields_for(object_name, *args, &proc)
    options = args.last.is_a?(Hash) ? args.pop : {}
    options[:template]= @template
    css_fields_for(object_name, *(args << options), &proc)
  end
  
  private
  
  def process(field,options,tag_output)
    unless (extra=options[:extra]).nil?
      tag_extra="<span style='float:left'>#{extra}</span>"
    else
      tag_extra=""
    end if
    input_field_id = "#{@object_name}_#{field}" 
    label=options[:label]
    label= (field.to_s.humanize) if label.nil?
    s="    <div class='form-field'>\n"
    s << "      <label for='#{input_field_id}'>#{label.translate}</label>\n" unless label==false
    s << "      #{tag_output} #{tag_extra}\n"
    s << "    </div>\n"
    s
  end
  
end

# Wrap form_for, using CssFormBuilder
#
def css_form_for(name, object = nil, options = {}, &proc)
  form_for(name, object, merge_form_options(options), &proc)
end

# Wrap remote_form_for, using CssFormBuilder
#
def remote_css_form_for(name, object = nil, options = {}, &proc)
  remote_form_for(name, object, merge_form_options(options), &proc)
end

# Wrap fields_for, using CssFormBuilder
#
def css_fields_for(object_name, *args, &proc)
  #fields_for(object_name, object, options.merge({:html=>{:class=>'cssform'},:builder => CssFormBuilder}), &proc)
  raise ArgumentError, "Missing block" unless block_given?
  options = args.last.is_a?(Hash) ? args.pop : {}
  object  = args.first
  template = options[:template] || self 
  yield((options[:builder] || CssFormBuilder).new(object_name, object, template, options, proc))
end

private

def merge_form_options(options)
  options[:html] ||= {}
  options[:html][:class]=('cssform '+(options[:html][:class] || '')).strip
  options.merge({:builder => CssFormBuilder})
end
